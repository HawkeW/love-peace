---
/**
 * OrganicBlob.astro - Soft organic morphing background
 * Inspired by smooothy.federic.ooo - but with light, airy aesthetic
 */
interface Props {
  class?: string;
  variant?: 'hero' | 'accent' | 'subtle';
}

const { class: className = '', variant = 'hero' } = Astro.props;
---

<div class:list={['organic-blob', `organic-blob--${variant}`, className]} data-organic-blob>
  <svg viewBox="0 0 800 800" preserveAspectRatio="none">
    <defs>
      <linearGradient id="blob-gradient-sage" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:#B8C4A8;stop-opacity:0.6" />
        <stop offset="50%" style="stop-color:#D4E0C8;stop-opacity:0.4" />
        <stop offset="100%" style="stop-color:#E8DED1;stop-opacity:0.3" />
      </linearGradient>
      <linearGradient id="blob-gradient-warm" x1="0%" y1="100%" x2="100%" y2="0%">
        <stop offset="0%" style="stop-color:#E8DED1;stop-opacity:0.5" />
        <stop offset="50%" style="stop-color:#F5EFE6;stop-opacity:0.3" />
        <stop offset="100%" style="stop-color:#C9A96E;stop-opacity:0.2" />
      </linearGradient>
      <filter id="blob-blur">
        <feGaussianBlur in="SourceGraphic" stdDeviation="30" />
      </filter>
    </defs>
    
    <g filter="url(#blob-blur)">
      <path class="blob blob-1" fill="url(#blob-gradient-sage)" />
      <path class="blob blob-2" fill="url(#blob-gradient-warm)" />
    </g>
  </svg>
</div>

<style>
  .organic-blob {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
  }

  .organic-blob svg {
    width: 100%;
    height: 100%;
    opacity: 0.8;
  }

  .organic-blob--hero svg {
    transform: scale(1.5);
  }

  .organic-blob--accent svg {
    transform: scale(1.2);
    opacity: 0.5;
  }

  .organic-blob--subtle svg {
    transform: scale(1);
    opacity: 0.3;
  }

  .blob {
    transform-origin: center;
  }

  @media (prefers-reduced-motion: reduce) {
    .blob {
      animation: none !important;
    }
  }
</style>

<script>
  import { prefersReducedMotion } from '../../utils/performance';

  class OrganicBlobAnimation {
    private blobs: NodeListOf<SVGPathElement>;
    private time = 0;
    private animationId: number | null = null;

    constructor(container: HTMLElement) {
      this.blobs = container.querySelectorAll('.blob');
      if (!prefersReducedMotion() && this.blobs.length > 0) {
        this.animate();
      } else {
        this.setStaticPaths();
      }
    }

    private generateBlobPath(
      cx: number, cy: number, 
      radius: number, 
      points: number, 
      variance: number,
      phase: number
    ): string {
      const angleStep = (Math.PI * 2) / points;
      const pathPoints: { x: number; y: number }[] = [];

      for (let i = 0; i < points; i++) {
        const angle = i * angleStep;
        const r = radius + Math.sin(angle * 3 + phase) * variance + 
                  Math.cos(angle * 2 + phase * 0.7) * variance * 0.5;
        pathPoints.push({
          x: cx + Math.cos(angle) * r,
          y: cy + Math.sin(angle) * r
        });
      }

      // Create smooth bezier curve
      let d = `M ${pathPoints[0].x} ${pathPoints[0].y}`;
      
      for (let i = 0; i < pathPoints.length; i++) {
        const p0 = pathPoints[(i - 1 + pathPoints.length) % pathPoints.length];
        const p1 = pathPoints[i];
        const p2 = pathPoints[(i + 1) % pathPoints.length];
        const p3 = pathPoints[(i + 2) % pathPoints.length];

        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;

        d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
      }

      return d + ' Z';
    }

    private setStaticPaths() {
      if (this.blobs[0]) {
        this.blobs[0].setAttribute('d', this.generateBlobPath(400, 350, 250, 8, 60, 0));
      }
      if (this.blobs[1]) {
        this.blobs[1].setAttribute('d', this.generateBlobPath(400, 450, 200, 6, 50, Math.PI));
      }
    }

    private animate = () => {
      this.time += 0.008;

      if (this.blobs[0]) {
        const path1 = this.generateBlobPath(400, 350, 250, 8, 60, this.time);
        this.blobs[0].setAttribute('d', path1);
      }

      if (this.blobs[1]) {
        const path2 = this.generateBlobPath(400, 450, 200, 6, 50, this.time * 0.7 + Math.PI);
        this.blobs[1].setAttribute('d', path2);
      }

      this.animationId = requestAnimationFrame(this.animate);
    };

    dispose() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Initialize
  document.querySelectorAll('[data-organic-blob]').forEach(container => {
    new OrganicBlobAnimation(container as HTMLElement);
  });
</script>
