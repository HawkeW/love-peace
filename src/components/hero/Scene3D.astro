---
---
<canvas id="hero-canvas"></canvas>

<script>
  import { loadThree } from '../../scripts/three-loader';

  const canvas = document.getElementById('hero-canvas') as HTMLCanvasElement;
  const reduceMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches ?? false;
  
  // Use IntersectionObserver to only render when visible
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        if (!reduceMotion) initScene(canvas);
        observer.disconnect(); // Initialize once
      }
    });
  });

  if (canvas) {
    observer.observe(canvas);
  }

  // Linear interpolation helper
  const lerp = (start: number, end: number, t: number) => {
    return start * (1 - t) + end * t;
  };

  async function initScene(canvas: HTMLCanvasElement) {
    const THREE = await loadThree();
    if (!THREE) return;

    canvas.style.opacity = '1';

    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0908, 0.035);
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 8; // Slightly further back for cinematic framing

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true, 
      antialias: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Performance cap

    // --- Particles (Atmospheric Dust) ---
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesCount = 400;
    const posArray = new Float32Array(particlesCount * 3);
    const scaleArray = new Float32Array(particlesCount);
    
    for(let i = 0; i < particlesCount; i++) {
        const i3 = i * 3;
        posArray[i3] = (Math.random() - 0.5) * 20;     // x
        posArray[i3 + 1] = (Math.random() - 0.5) * 12; // y
        posArray[i3 + 2] = (Math.random() - 0.5) * 10; // z
        scaleArray[i] = Math.random();
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    particlesGeometry.setAttribute('aScale', new THREE.BufferAttribute(scaleArray, 1));
    const basePositions = new Float32Array(posArray);
    
    // Custom Shader Material for particles (Soft Glow)
    // Using simple PointsMaterial for stability but mimicking glow with opacity
    const particleMaterial = new THREE.PointsMaterial({
        size: 0.08,
        color: 0xD4AF37, // Champagne Gold
        transparent: true,
        opacity: 0.42,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });
    
    const particlesMesh = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particlesMesh);
    const targetParticleColor = new THREE.Color(0xD4AF37);
    let targetParticleSize = 0.08;
    let targetParticleOpacity = 0.42;
    let targetWaveAmp = 0.02;

    // --- Characters ---
    const loader = new THREE.TextureLoader();
    const characters: any[] = [];
    const uniforms = {
      mood: { value: 0 }, // 0-1
      tint: { value: new THREE.Color(0xD4AF37) }
    };

    const createCharacter = (path: string, x: number, z: number, scale: number = 1) => {
        loader.load(path, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0 // Fade in start
            });
            
            const aspect = texture.image.width / texture.image.height;
            const height = 5 * scale;
            const width = height * aspect;
            
            const geometry = new THREE.PlaneGeometry(width, height);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, -0.5, z);
            
            // Store initial data for animation
            mesh.userData = {
                initialY: -0.5,
                initialX: x,
                targetOpacity: 1,
                floatOffset: Math.random() * 100
            };
            
            scene.add(mesh);
            characters.push(mesh);
        });
    };

    createCharacter('/people/groom.png', -1.5, 0, 1.05); // Left
    createCharacter('/people/bride.png', 1.5, 0.5, 1.05); // Right

    // --- Interaction State ---
    const mouse = { x: 0, y: 0 };
    const targetMouse = { x: 0, y: 0 };
    let chapterIndex = 0;
    
    // Throttled mouse move
    let ticking = false;
    window.addEventListener('mousemove', (event) => {
        if (!ticking) {
            window.requestAnimationFrame(() => {
                targetMouse.x = (event.clientX / window.innerWidth - 0.5) * 2; // -1 to 1
                targetMouse.y = -(event.clientY / window.innerHeight - 0.5) * 2; // -1 to 1
                ticking = false;
            });
            ticking = true;
        }
    });

    // Gyroscope for mobile
    window.addEventListener('deviceorientation', (event) => {
        if (event.beta && event.gamma) {
            targetMouse.y = Math.min(Math.max(event.beta / 45, -1), 1);
            targetMouse.x = Math.min(Math.max(event.gamma / 45, -1), 1);
        }
    });

    // --- Animation Loop ---
    const clock = new THREE.Clock();
    let rafId: number | null = null;
    let paused = document.hidden;
    let heroVisible = true;

    const start = () => {
      if (rafId !== null) return;
      rafId = requestAnimationFrame(tick);
    };

    const stop = () => {
      if (rafId === null) return;
      cancelAnimationFrame(rafId);
      rafId = null;
    };

    const syncPause = () => {
      paused = document.hidden || !heroVisible;
      canvas.style.opacity = heroVisible ? '1' : '0';
      if (paused) stop();
      else start();
    };

    const tick = () => {
      rafId = requestAnimationFrame(tick);
        
      const elapsedTime = clock.getElapsedTime();
      const deltaTime = clock.getDelta();

      if (paused) return;

      mouse.x = lerp(mouse.x, targetMouse.x, 0.05);
      mouse.y = lerp(mouse.y, targetMouse.y, 0.05);
        
      camera.position.x = lerp(camera.position.x, mouse.x * 0.5, 0.05);
      camera.position.y = lerp(camera.position.y, mouse.y * 0.5, 0.05);
      camera.lookAt(0, 0, 0);

      const baseSpin = 0.02 + (chapterIndex * 0.004);
      particlesMesh.rotation.y = elapsedTime * baseSpin;
      particlesMesh.rotation.x = -mouse.y * (0.08 + chapterIndex * 0.01);
      particlesMesh.rotation.z = mouse.x * (0.08 + chapterIndex * 0.01);

      const positions = particlesGeometry.attributes.position.array as Float32Array;
      for(let i = 0; i < particlesCount; i++) {
        const i3 = i * 3;
        positions[i3 + 1] = basePositions[i3 + 1] + Math.sin(elapsedTime * 0.5 + basePositions[i3]) * targetWaveAmp;
      }
      particlesGeometry.attributes.position.needsUpdate = true;

      characters.forEach((mesh) => {
        if (mesh.material.opacity < 1) {
          mesh.material.opacity += 0.02;
        }

        mesh.position.y = mesh.userData.initialY + Math.sin(elapsedTime + mesh.userData.floatOffset) * 0.05;
            
        const rotX = -mouse.y * 0.05;
        const rotY = mouse.x * 0.05;
        mesh.rotation.x = lerp(mesh.rotation.x, rotX, 0.1);
        mesh.rotation.y = lerp(mesh.rotation.y, rotY, 0.1);
            
        const depthFactor = mesh.position.z * (0.18 + chapterIndex * 0.02);
        mesh.position.x = mesh.userData.initialX + (mouse.x * depthFactor);
      });

      const targetMood = Math.min(1, Math.max(0, chapterIndex / 6));
      uniforms.mood.value = lerp(uniforms.mood.value, targetMood, 0.05);

      particleMaterial.color.lerp(targetParticleColor, 0.06);
      particleMaterial.size = lerp(particleMaterial.size, targetParticleSize, 0.06);
      particleMaterial.opacity = lerp(particleMaterial.opacity, targetParticleOpacity, 0.06);

      renderer.render(scene, camera);
    };
    
    start();

    document.addEventListener('visibilitychange', () => {
      syncPause();
    });

    // Resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const hero = document.getElementById('hero');
    if (hero) {
      const heroObserver = new IntersectionObserver(
        (entries) => {
          const e = entries[0];
          heroVisible = !!e?.isIntersecting;
          syncPause();
        },
        { threshold: 0.15 }
      );
      heroObserver.observe(hero);
    }

    // --- Chapter events linkage ---
    window.addEventListener('lp:chapter', (e: any) => {
      const idx = Number(e.detail?.index ?? 0);
      chapterIndex = idx;
      const palette = [0xD4AF37, 0xE94E77, 0x9AD1D4, 0xF2F0E9];
      targetParticleColor.setHex(palette[idx % palette.length]);
      targetParticleSize = 0.075 + (idx % 4) * 0.01;
      targetParticleOpacity = 0.38 + (idx % 3) * 0.06;
      targetWaveAmp = 0.012 + (idx % 4) * 0.006;
    });
  }
</script>

<style>
  #hero-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    display: block;
    z-index: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 600ms var(--ease-out-expo);
  }

  @media (prefers-reduced-motion: reduce) {
    #hero-canvas {
      display: none;
    }
  }
</style>
