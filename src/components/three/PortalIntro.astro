---
/**
 * PortalIntro.astro - Opening portal effect
 * Golden ring (wedding ring metaphor) that expands and reveals the content
 */
interface Props {
  title?: string;
  subtitle?: string;
  groomName?: string;
  brideName?: string;
}

const {
  title = "婚礼邀请函",
  subtitle = "诚挚邀请您莅临见证我们的幸福时刻",
  groomName = "王浩",
  brideName = "何晓雅",
} = Astro.props;
---

<section class="portal-intro" id="portal-intro">
  <canvas id="portal-canvas"></canvas>

  <div class="portal-content">
    <div class="names">
      <span class="name groom">{groomName}</span>
      <span class="ampersand">&</span>
      <span class="name bride">{brideName}</span>
    </div>
    <h1 class="title">{title}</h1>
    <p class="subtitle">{subtitle}</p>
    <div class="scroll-hint">
      <span>向下滑动探索</span>
      <div class="scroll-icon"></div>
    </div>
  </div>
</section>

<style>
  .portal-intro {
    position: relative;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    overflow: hidden;
    background: var(--midnight-blue, #0d1b2a);
  }

  #portal-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .portal-content {
    position: relative;
    z-index: 2;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 20px;
    text-align: center;
    color: #fff;
    opacity: 0;
    transform: scale(0.9);
    transition:
      opacity 1s ease,
      transform 1s ease;
  }

  .portal-content.visible {
    opacity: 1;
    transform: scale(1);
  }

  .names {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 24px;
  }

  .name {
    font-family: var(--font-elegant, "Cormorant Garamond", serif);
    font-size: clamp(28px, 8vw, 48px);
    font-weight: 300;
    letter-spacing: 0.1em;
    background: linear-gradient(135deg, #d4af37, #b76e79);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .ampersand {
    font-family: var(--font-elegant, "Cormorant Garamond", serif);
    font-size: clamp(24px, 6vw, 36px);
    color: var(--neon-coral, #ff6b6b);
    opacity: 0.8;
  }

  .title {
    font-family: var(--font-modern, "Space Grotesk", sans-serif);
    font-size: clamp(16px, 4vw, 24px);
    font-weight: 400;
    margin: 0 0 12px;
    letter-spacing: 0.2em;
    color: rgba(255, 255, 255, 0.9);
  }

  .subtitle {
    font-size: clamp(14px, 3vw, 16px);
    margin: 0;
    color: rgba(255, 255, 255, 0.6);
    max-width: 300px;
  }

  .scroll-hint {
    position: absolute;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    color: rgba(255, 255, 255, 0.5);
    font-size: 12px;
    animation: float 2s ease-in-out infinite;
  }

  .scroll-icon {
    width: 24px;
    height: 40px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    position: relative;
  }

  .scroll-icon::before {
    content: "";
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 8px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 2px;
    animation: scroll-dot 1.5s ease-in-out infinite;
  }

  @keyframes float {
    0%,
    100% {
      transform: translateX(-50%) translateY(0);
    }
    50% {
      transform: translateX(-50%) translateY(-8px);
    }
  }

  @keyframes scroll-dot {
    0%,
    100% {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    50% {
      opacity: 0.3;
      transform: translateX(-50%) translateY(8px);
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .portal-content {
      opacity: 1;
      transform: none;
      transition: none;
    }
    .scroll-hint,
    .scroll-icon::before {
      animation: none;
    }
  }
</style>

<script>
  import * as THREE from "three";
  import gsap from "gsap";
  import {
    createRenderer,
    createCamera,
    disposeResources,
  } from "../../utils/three-helpers";
  import { prefersReducedMotion } from "../../utils/performance";

  class PortalScene {
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private ring: THREE.Mesh | null = null;
    private particles: THREE.Points | null = null;
    private time = 0;
    private isAnimating = true;
    private container: HTMLElement;

    constructor(canvas: HTMLCanvasElement, container: HTMLElement) {
      this.container = container;
      this.scene = new THREE.Scene();

      // Camera
      this.camera = createCamera(
        60,
        container.clientWidth / container.clientHeight,
        0.1,
        100
      );
      this.camera.position.z = 4;

      // Renderer
      const pixelRatio =
        (window as any).__optimalPixelRatio ||
        Math.min(window.devicePixelRatio, 2);
      this.renderer = createRenderer(canvas, {
        pixelRatio,
        antialias: true,
        alpha: true,
      });
      this.renderer.setSize(container.clientWidth, container.clientHeight);
      this.renderer.setClearColor(0x000000, 0);

      this.createRing();
      this.createParticles();
      this.setupResize();

      if (!prefersReducedMotion()) {
        this.animate();
        this.playIntroAnimation();
      } else {
        this.showContent();
      }
    }

    private createRing() {
      // Golden ring geometry
      const geometry = new THREE.TorusGeometry(1.5, 0.08, 32, 100);

      // Custom shader for golden metallic effect
      const material = new THREE.ShaderMaterial({
        vertexShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          uniform float uTime;
          
          void main() {
            vNormal = normal;
            vPosition = position;
            
            vec3 pos = position;
            pos.z += sin(uTime * 2.0 + position.x * 3.0) * 0.02;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          varying vec3 vPosition;
          uniform float uTime;
          
          void main() {
            vec3 gold1 = vec3(0.83, 0.69, 0.22);
            vec3 gold2 = vec3(0.72, 0.43, 0.47);
            
            float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
            vec3 color = mix(gold1, gold2, fresnel + sin(uTime * 0.5) * 0.1);
            
            float glow = 0.5 + fresnel * 0.5;
            
            gl_FragColor = vec4(color * glow, 1.0);
          }
        `,
        uniforms: {
          uTime: { value: 0 },
        },
      });

      this.ring = new THREE.Mesh(geometry, material);
      this.ring.scale.set(0, 0, 0);
      this.scene.add(this.ring);
    }

    private createParticles() {
      const count = 2000;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const radius = 1.5 + Math.random() * 2;

        positions[i3] = Math.cos(theta) * radius;
        positions[i3 + 1] = (Math.random() - 0.5) * 4;
        positions[i3 + 2] =
          Math.sin(theta) * radius + (Math.random() - 0.5) * 2;

        // Golden particles
        colors[i3] = 0.9 + Math.random() * 0.1;
        colors[i3 + 1] = 0.6 + Math.random() * 0.3;
        colors[i3 + 2] = 0.2 + Math.random() * 0.2;

        sizes[i] = Math.random() * 3 + 1;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.ShaderMaterial({
        vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float uTime;
          
          void main() {
            vColor = color;
            
            vec3 pos = position;
            float angle = uTime * 0.2;
            float c = cos(angle);
            float s = sin(angle);
            pos.xz = vec2(pos.x * c - pos.z * s, pos.x * s + pos.z * c);
            pos.y += sin(uTime + position.x * 2.0) * 0.1;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          
          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            
            float alpha = 1.0 - dist * 2.0;
            alpha = pow(alpha, 1.5);
            
            gl_FragColor = vec4(vColor, alpha * 0.6);
          }
        `,
        uniforms: {
          uTime: { value: 0 },
        },
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      this.particles = new THREE.Points(geometry, material);
      this.particles.scale.set(0, 0, 0);
      this.scene.add(this.particles);
    }

    private playIntroAnimation() {
      const tl = gsap.timeline({ delay: 0.5 });

      // Ring expansion
      if (this.ring) {
        tl.to(
          this.ring.scale,
          {
            x: 1,
            y: 1,
            z: 1,
            duration: 1.5,
            ease: "elastic.out(1, 0.5)",
          },
          0
        );

        tl.to(
          this.ring.rotation,
          {
            z: Math.PI * 0.1,
            duration: 2,
            ease: "power2.out",
          },
          0
        );
      }

      // Particles expansion
      if (this.particles) {
        tl.to(
          this.particles.scale,
          {
            x: 1,
            y: 1,
            z: 1,
            duration: 2,
            ease: "power2.out",
          },
          0.3
        );
      }

      // Show content
      tl.add(() => this.showContent(), 1.2);
    }

    private showContent() {
      const content = document.querySelector(".portal-content");
      content?.classList.add("visible");
    }

    private setupResize() {
      const handleResize = () => {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      };

      window.addEventListener("resize", handleResize);
    }

    private animate = () => {
      if (!this.isAnimating) return;

      this.time += 0.016;

      // Update ring shader
      if (this.ring) {
        (this.ring.material as THREE.ShaderMaterial).uniforms.uTime.value =
          this.time;
        this.ring.rotation.z += 0.002;
      }

      // Update particles shader
      if (this.particles) {
        (this.particles.material as THREE.ShaderMaterial).uniforms.uTime.value =
          this.time;
      }

      this.renderer.render(this.scene, this.camera);
      requestAnimationFrame(this.animate);
    };

    dispose() {
      this.isAnimating = false;
      disposeResources(this.scene, this.renderer);
    }
  }

  // Initialize on page load
  document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.getElementById(
      "portal-canvas"
    ) as HTMLCanvasElement;
    const container = document.getElementById("portal-intro");

    if (canvas && container) {
      new PortalScene(canvas, container);
    }
  });
</script>
