---
export interface Props {
  backgroundImage?: string;
  foregroundImages?: string[]; // 支持多张图片循环
  foregroundImage?: string; // 向后兼容单张图片
  title: string;
  subtitle?: string;
  date?: string;
}

const {
  backgroundImage,
  foregroundImages,
  foregroundImage,
  title,
  subtitle,
  date,
} = Astro.props;

// 处理前景图片：优先使用数组，否则回退到单张图片
const fgImages = foregroundImages || (foregroundImage ? [foregroundImage] : []);

// Parse the couple's names (format: "Name1 & Name2")
const names = title.split(/\s*&\s*/);
const name1 = names[0] || "";
const name2 = names[1] || "";
const name1Chars = [...name1];
const name2Chars = [...name2];
---

<section class="parallax-hero" data-hero>
  <!-- Image Area (60vh) -->
  <div class="hero-image-area">
    <!-- Background layer (pattern/texture) -->
    {
      backgroundImage && (
        <div
          class="hero-bg-layer"
          style={`background-image: url('${backgroundImage}')`}
        />
      )
    }

    <!-- Foreground layer (people photos - carousel) -->
    {
      fgImages.length > 0 && (
        <div class="hero-fg-layer" data-fg-carousel>
          {fgImages.map((src, index) => (
            <img
              src={src}
              alt={`Wedding Photo ${index + 1}`}
              class={`hero-fg-image ${index === 0 ? "active" : ""}`}
              data-index={index}
            />
          ))}
        </div>
      )
    }

    <!-- Gradient overlay for smooth transition -->
    <div class="hero-overlay"></div>

    <!-- Decorative frame -->
    <div class="hero-frame">
      <div class="frame-corner frame-tl"></div>
      <div class="frame-corner frame-tr"></div>
    </div>
  </div>

  <!-- Content Area (40vh) -->
  <div class="hero-content">
    <div class="content-inner">
      <!-- Top accent -->
      <div class="hero-accent">
        <span class="accent-line"></span>
        <span class="accent-text">Wedding Invitation</span>
        <span class="accent-line"></span>
      </div>

      <!-- Main title -->
      <h1 class="hero-title">
        {
          name1Chars.map((char, i) => (
            <span class="title-char" style={`--char-index: ${i}`}>
              {char}
            </span>
          ))
        }
        <span class="title-divider">&</span>
        {
          name2Chars.map((char, i) => (
            <span
              class="title-char"
              style={`--char-index: ${name1Chars.length + i}`}
            >
              {char}
            </span>
          ))
        }
      </h1>

      {subtitle && <p class="hero-subtitle">{subtitle}</p>}

      <!-- Slot for EnvelopeSeal -->
      <div class="hero-slot-container">
        <slot />
      </div>
    </div>
  </div>
</section>

<script>
  const hero = document.querySelector("[data-hero]") as HTMLElement;
  const bgLayer = document.querySelector(".hero-bg-layer") as HTMLElement;
  const fgCarousel = document.querySelector(
    "[data-fg-carousel]"
  ) as HTMLElement;
  const fgImages = document.querySelectorAll(
    ".hero-fg-image"
  ) as NodeListOf<HTMLImageElement>;
  const content = document.querySelector(".hero-content") as HTMLElement;
  const frame = document.querySelector(".hero-frame") as HTMLElement;

  // 图片循环切换和随机角度变化
  if (fgImages.length > 1) {
    let currentIndex = 0;
    const totalImages = fgImages.length;

    // 生成随机角度 (-10 到 10 度)
    const getRandomRotation = () => {
      return (Math.random() - 0.5) * 20; // -10 到 10 度
    };

    // 设置初始随机角度并启动摆动动画
    const activateImage = (img: HTMLImageElement) => {
      const rotation = getRandomRotation();
      img.style.setProperty("--rotation", `${rotation}deg`);
      img.classList.add("active");
      // 启动摆动动画
      img.classList.remove("wobbling");
      void img.offsetWidth; // 强制 reflow
      img.classList.add("wobbling");
    };

    // 初始化第一张图片
    activateImage(fgImages[0]);

    // 切换图片
    const switchImage = () => {
      // 移除当前图片的 active 状态
      fgImages[currentIndex].classList.remove("active", "wobbling");

      // 计算下一张图片索引
      currentIndex = (currentIndex + 1) % totalImages;

      // 激活新图片并启动摆动
      activateImage(fgImages[currentIndex]);
    };

    // 每 3 秒切换一次（2秒摆动 + 1秒停顿）
    setInterval(switchImage, 3000);
  } else if (fgImages.length === 1) {
    // 单张图片也添加随机角度和摆动
    const img = fgImages[0];
    const rotation = (Math.random() - 0.5) * 20;
    img.style.setProperty("--rotation", `${rotation}deg`);
    img.classList.add("wobbling");
  }

  // 视差滚动效果
  if (hero && content) {
    let ticking = false;

    const updateParallax = () => {
      const scrollY = window.scrollY;
      const heroHeight = hero.offsetHeight;
      const scrollProgress = Math.min(scrollY / heroHeight, 1);

      // Background layer - slow parallax
      if (bgLayer) {
        const bgTranslate = scrollY * 0.2;
        bgLayer.style.transform = `translateY(${bgTranslate}px)`;
      }

      // Content fade and lift
      content.style.opacity = String(1 - scrollProgress * 1.5);
      content.style.transform = `translateY(${scrollY * 0.15}px)`;

      // Frame fade
      if (frame) {
        frame.style.opacity = String(1 - scrollProgress * 1.5);
      }

      ticking = false;
    };

    window.addEventListener(
      "scroll",
      () => {
        if (!ticking) {
          requestAnimationFrame(updateParallax);
          ticking = true;
        }
      },
      { passive: true }
    );
  }

  // Staggered reveal animation
  const chars = document.querySelectorAll(".title-char");
  chars.forEach((char, i) => {
    (char as HTMLElement).style.animationDelay = `${0.5 + i * 0.1}s`;
  });
</script>

<style>
  .parallax-hero {
    position: relative;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    min-height: 600px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    transition:
      opacity 0.5s ease,
      transform 0.5s ease;
  }

  /* 信封开启过渡动画 */
  .parallax-hero.transitioning {
    opacity: 0.3;
    transform: scale(0.98);
  }

  /* Image Area - 60vh */
  .hero-image-area {
    position: relative;
    width: 100%;
    height: 60vh;
    height: 60dvh;
    flex-shrink: 0;
    overflow: hidden;
  }

  /* Background Layer - Pattern/Texture - Repeat Fill */
  .hero-bg-layer {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    background-size: auto;
    background-repeat: repeat;
    background-position: center;
    will-change: transform;
    z-index: 1;
  }

  /* Foreground Layer - People Photo Carousel */
  .hero-fg-layer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }

  .hero-fg-image {
    --rotation: 0deg;
    position: absolute;
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    will-change: transform;
    opacity: 0;
    transform: rotate(var(--rotation));
    pointer-events: none;
  }

  .hero-fg-image.active {
    opacity: 1;
    pointer-events: auto;
  }

  /* 俯皮的角度切换动画 - 每0.5秒切换一次，共3次 */
  .hero-fg-image.wobbling {
    animation: playfulTilt 1.5s steps(1) forwards;
  }

  @keyframes playfulTilt {
    0% {
      transform: rotate(var(--rotation));
    }
    33.33% {
      transform: rotate(calc(var(--rotation) + 8deg));
    }
    66.66% {
      transform: rotate(calc(var(--rotation) - 6deg));
    }
    100% {
      transform: rotate(calc(var(--rotation) + 3deg));
    }
  }

  /* Gradient overlay - bottom fade for seamless transition */
  .hero-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(
      to bottom,
      transparent 0%,
      rgba(10, 10, 10, 0.3) 40%,
      rgba(10, 10, 10, 0.7) 70%,
      var(--bg-primary, #0a0a0a) 100%
    );
    z-index: 3;
    pointer-events: none;
  }

  /* Decorative Frame - only top corners */
  .hero-frame {
    position: absolute;
    inset: 20px;
    pointer-events: none;
    z-index: 4;
    opacity: 0;
    animation: fadeIn 1.2s ease-out 0.3s forwards;
  }

  .frame-corner {
    position: absolute;
    width: 50px;
    height: 50px;
    border-color: var(--gold, #c9a962);
    border-style: solid;
    border-width: 0;
    opacity: 0.5;
  }

  .frame-tl {
    top: 0;
    left: 0;
    border-top-width: 1px;
    border-left-width: 1px;
  }

  .frame-tr {
    top: 0;
    right: 0;
    border-top-width: 1px;
    border-right-width: 1px;
  }

  /* Content Area - 40vh */
  .hero-content {
    position: relative;
    width: 100%;
    height: 40vh;
    height: 40dvh;
    flex-shrink: 0;
    background: var(--bg-primary, #0a0a0a);
    z-index: 5;
    text-align: center;
    padding: 24px 24px 32px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    will-change: transform, opacity;
  }

  .content-inner {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
  }

  /* Top Accent */
  .hero-accent {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    opacity: 0;
    animation: fadeIn 0.8s ease-out 0.2s forwards;
  }

  .accent-line {
    width: 40px;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--gold, #c9a962));
  }

  .accent-line:last-child {
    background: linear-gradient(90deg, var(--gold, #c9a962), transparent);
  }

  .accent-text {
    font-family: "Playfair Display", Georgia, serif;
    font-size: 11px;
    font-style: italic;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--gold, #c9a962);
  }

  /* Title */
  .hero-title {
    font-family: "Dongjingjiejiao", Georgia, serif;
    font-size: clamp(2.5rem, 10vw, 5rem);
    font-weight: 400;
    letter-spacing: 0.08em;
    color: var(--text-primary, #fafafa);
    margin: 0;
    text-shadow: 0 4px 40px rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    gap: 0;
  }

  .title-char {
    display: inline-block;
    opacity: 0;
    transform: translateY(30px);
    animation: charReveal 0.6s ease-out forwards;
  }

  .title-divider {
    display: inline-block;
    margin: 0 0.15em;
    font-style: italic;
    color: var(--gold, #c9a962);
    opacity: 0;
    animation: fadeIn 0.6s ease-out 0.8s forwards;
  }

  @keyframes charReveal {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .hero-subtitle {
    font-family: "Dongjingjiejiao", Georgia, serif;
    font-size: clamp(0.9rem, 2.5vw, 1.1rem);
    font-weight: 400;
    letter-spacing: 0.25em;
    color: var(--text-secondary, #a0a0a0);
    margin: 0;
    opacity: 0;
    animation: fadeIn 0.8s ease-out 1s forwards;
  }

  /* Slot container for EnvelopeSeal */
  .hero-slot-container {
    margin-top: 8px;
    opacity: 0;
    animation: fadeIn 0.8s ease-out 1.2s forwards;
  }

  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }

  /* Mobile Optimization */
  @media (max-width: 768px) {
    .parallax-hero {
      min-height: 100vh;
      min-height: 100dvh;
    }

    .hero-image-area {
      height: 60vh;
      height: 60dvh;
    }

    /* 移动端图片充分利用60vh空间 */
    .hero-fg-image {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center top;
    }

    .hero-frame {
      inset: 12px;
    }

    .frame-corner {
      width: 32px;
      height: 32px;
    }

    .hero-content {
      height: 40vh;
      height: 40dvh;
      padding: 20px 20px 24px;
    }

    .content-inner {
      gap: 10px;
    }

    .hero-accent {
      gap: 12px;
    }

    .accent-line {
      width: 24px;
    }

    .accent-text {
      font-size: 9px;
      letter-spacing: 0.2em;
    }

    .hero-title {
      letter-spacing: 0.05em;
    }

    .hero-subtitle {
      letter-spacing: 0.15em;
    }

    .hero-slot-container {
      margin-top: 4px;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .hero-fg-image {
      animation: none !important;
    }

    .title-char,
    .hero-accent,
    .hero-subtitle,
    .hero-slot-container,
    .hero-frame,
    .title-divider {
      opacity: 1;
      transform: none;
      animation: none;
    }
  }
</style>
