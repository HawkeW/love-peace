---
// CurvedImageRenderer.astro - WebGL曲线图片渲染组件
---

<div id="curved-image-container">
  <canvas id="curved-image-canvas" width="800" height="600"></canvas>
  <div class="controls">
    <div class="control-group">
      <label>上边曲线强度:</label>
      <input type="range" id="topCurve" min="-0.5" max="0.5" step="0.01" value="0.2">
    </div>
    <div class="control-group">
      <label>下边曲线强度:</label>
      <input type="range" id="bottomCurve" min="-0.5" max="0.5" step="0.01" value="-0.2">
    </div>
    <div class="control-group">
      <label>左边曲线强度:</label>
      <input type="range" id="leftCurve" min="-0.5" max="0.5" step="0.01" value="0.15">
    </div>
    <div class="control-group">
      <label>右边曲线强度:</label>
      <input type="range" id="rightCurve" min="-0.5" max="0.5" step="0.01" value="-0.15">
    </div>
    <div class="control-group">
      <label>选择图片:</label>
      <input type="file" id="imageInput" accept="image/*">
    </div>
  </div>
</div>

<style>
  #curved-image-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: #f0f0f0;
    border-radius: 10px;
    margin: 20px;
  }

  #curved-image-canvas {
    border: 2px solid #333;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }

  .controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-top: 20px;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .control-group label {
    font-weight: bold;
    color: #333;
    font-size: 14px;
  }

  .control-group input[type="range"] {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #ddd;
    outline: none;
  }

  .control-group input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #4CAF50;
    cursor: pointer;
  }

  .control-group input[type="file"] {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
  }
</style>

<script>
  // WebGL曲线图片渲染器
  class CurvedImageRenderer {
    constructor(canvasId) {
      this.canvas = document.getElementById(canvasId);
      this.gl = this.canvas.getContext('webgl');
      
      if (!this.gl) {
        console.error('WebGL not supported');
        return;
      }

      this.program = null;
      this.texture = null;
      this.positionBuffer = null;
      this.texCoordBuffer = null;
      
      // 曲线参数
      this.curves = {
        top: 0.2,
        bottom: -0.2,
        left: 0.15,
        right: -0.15
      };

      this.init();
    }

    // 顶点着色器源码
    getVertexShaderSource() {
      return `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        
        uniform float u_topCurve;
        uniform float u_bottomCurve;
        uniform float u_leftCurve;
        uniform float u_rightCurve;
        
        varying vec2 v_texCoord;
        
        void main() {
          vec2 position = a_position;
          
          // 应用曲线变形
          // 上下边曲线 (基于x坐标)
          float xFactor = position.x * position.x;
          if (position.y > 0.0) {
            position.y += u_topCurve * xFactor;
          } else {
            position.y += u_bottomCurve * xFactor;
          }
          
          // 左右边曲线 (基于y坐标)
          float yFactor = position.y * position.y;
          if (position.x > 0.0) {
            position.x += u_rightCurve * yFactor;
          } else {
            position.x += u_leftCurve * yFactor;
          }
          
          gl_Position = vec4(position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `;
    }

    // 片段着色器源码
    getFragmentShaderSource() {
      return `
        precision mediump float;
        
        uniform sampler2D u_texture;
        varying vec2 v_texCoord;
        
        void main() {
          gl_FragColor = texture2D(u_texture, v_texCoord);
        }
      `;
    }

    // 创建着色器
    createShader(type, source) {
      const shader = this.gl.createShader(type);
      this.gl.shaderSource(shader, source);
      this.gl.compileShader(shader);
      
      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
        this.gl.deleteShader(shader);
        return null;
      }
      
      return shader;
    }

    // 创建程序
    createProgram() {
      const vertexShader = this.createShader(this.gl.VERTEX_SHADER, this.getVertexShaderSource());
      const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.getFragmentShaderSource());
      
      if (!vertexShader || !fragmentShader) {
        return null;
      }
      
      const program = this.gl.createProgram();
      this.gl.attachShader(program, vertexShader);
      this.gl.attachShader(program, fragmentShader);
      this.gl.linkProgram(program);
      
      if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('Program linking error:', this.gl.getProgramInfoLog(program));
        this.gl.deleteProgram(program);
        return null;
      }
      
      return program;
    }

    // 创建缓冲区
    createBuffers() {
      // 创建网格顶点 (更密集的网格以获得更平滑的曲线)
      const resolution = 50;
      const vertices = [];
      const texCoords = [];
      const indices = [];
      
      // 生成网格顶点
      for (let i = 0; i <= resolution; i++) {
        for (let j = 0; j <= resolution; j++) {
          const x = (i / resolution) * 2 - 1; // -1 到 1
          const y = (j / resolution) * 2 - 1; // -1 到 1
          
          vertices.push(x, y);
          
          const u = i / resolution; // 0 到 1
          const v = 1 - (j / resolution); // 0 到 1 (翻转v坐标)
          texCoords.push(u, v);
        }
      }
      
      // 生成索引
      for (let i = 0; i < resolution; i++) {
        for (let j = 0; j < resolution; j++) {
          const topLeft = i * (resolution + 1) + j;
          const topRight = topLeft + 1;
          const bottomLeft = (i + 1) * (resolution + 1) + j;
          const bottomRight = bottomLeft + 1;
          
          // 第一个三角形
          indices.push(topLeft, bottomLeft, topRight);
          // 第二个三角形
          indices.push(topRight, bottomLeft, bottomRight);
        }
      }
      
      // 创建位置缓冲区
      this.positionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertices), this.gl.STATIC_DRAW);
      
      // 创建纹理坐标缓冲区
      this.texCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(texCoords), this.gl.STATIC_DRAW);
      
      // 创建索引缓冲区
      this.indexBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
      
      this.indexCount = indices.length;
    }

    // 创建纹理
    createTexture(image) {
      const texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
      
      // 设置纹理参数
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
      
      // 上传图像数据
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
      
      return texture;
    }

    // 初始化
    init() {
      this.program = this.createProgram();
      if (!this.program) {
        console.error('Failed to create WebGL program');
        return;
      }
      
      this.createBuffers();
      
      // 获取attribute和uniform位置
      this.positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
      this.texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');
      
      this.topCurveLocation = this.gl.getUniformLocation(this.program, 'u_topCurve');
      this.bottomCurveLocation = this.gl.getUniformLocation(this.program, 'u_bottomCurve');
      this.leftCurveLocation = this.gl.getUniformLocation(this.program, 'u_leftCurve');
      this.rightCurveLocation = this.gl.getUniformLocation(this.program, 'u_rightCurve');
      this.textureLocation = this.gl.getUniformLocation(this.program, 'u_texture');
      
      // 加载默认图像
      this.loadDefaultImage();
    }

    // 加载默认图像
    loadDefaultImage() {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      
      // 创建渐变背景
      const gradient = ctx.createLinearGradient(0, 0, 256, 256);
      gradient.addColorStop(0, '#ff6b6b');
      gradient.addColorStop(0.5, '#4ecdc4');
      gradient.addColorStop(1, '#45b7d1');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 256, 256);
      
      // 添加一些装饰
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * 256;
        const y = Math.random() * 256;
        const radius = Math.random() * 20 + 5;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // 添加文字
      ctx.fillStyle = 'white';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('WebGL', 128, 120);
      ctx.fillText('曲线渲染', 128, 150);
      
      this.loadImageFromCanvas(canvas);
    }

    // 从canvas加载图像
    loadImageFromCanvas(canvas) {
      if (this.texture) {
        this.gl.deleteTexture(this.texture);
      }
      this.texture = this.createTexture(canvas);
      this.render();
    }

    // 从文件加载图像
    loadImageFromFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          if (this.texture) {
            this.gl.deleteTexture(this.texture);
          }
          this.texture = this.createTexture(img);
          this.render();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // 更新曲线参数
    updateCurves(curves) {
      this.curves = { ...this.curves, ...curves };
      this.render();
    }

    // 渲染
    render() {
      if (!this.program || !this.texture) {
        return;
      }
      
      // 设置视口
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      
      // 清除画布
      this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      
      // 使用程序
      this.gl.useProgram(this.program);
      
      // 绑定位置缓冲区
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
      this.gl.enableVertexAttribArray(this.positionLocation);
      this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
      
      // 绑定纹理坐标缓冲区
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texCoordBuffer);
      this.gl.enableVertexAttribArray(this.texCoordLocation);
      this.gl.vertexAttribPointer(this.texCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
      
      // 设置uniform
      this.gl.uniform1f(this.topCurveLocation, this.curves.top);
      this.gl.uniform1f(this.bottomCurveLocation, this.curves.bottom);
      this.gl.uniform1f(this.leftCurveLocation, this.curves.left);
      this.gl.uniform1f(this.rightCurveLocation, this.curves.right);
      
      // 绑定纹理
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
      this.gl.uniform1i(this.textureLocation, 0);
      
      // 绑定索引缓冲区并绘制
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.drawElements(this.gl.TRIANGLES, this.indexCount, this.gl.UNSIGNED_SHORT, 0);
    }
  }

  // 初始化渲染器
  let renderer;
  
  document.addEventListener('DOMContentLoaded', () => {
    renderer = new CurvedImageRenderer('curved-image-canvas');
    
    // 绑定控制器事件
    const controls = {
      topCurve: document.getElementById('topCurve'),
      bottomCurve: document.getElementById('bottomCurve'),
      leftCurve: document.getElementById('leftCurve'),
      rightCurve: document.getElementById('rightCurve'),
      imageInput: document.getElementById('imageInput')
    };
    
    // 曲线控制器事件
    Object.keys(controls).forEach(key => {
      if (key !== 'imageInput') {
        controls[key].addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          renderer.updateCurves({ [key.replace('Curve', '')]: value });
        });
      }
    });
    
    // 图片上传事件
    controls.imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file && file.type.startsWith('image/')) {
        renderer.loadImageFromFile(file);
      }
    });
  });
</script>